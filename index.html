<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SkyPredict Demo</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #1a2980, #26d0ce);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            padding: 20px 0;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .tagline {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .dashboard {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        @media (max-width: 768px) {
            .dashboard {
                grid-template-columns: 1fr;
            }
        }

        .card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .card h2 {
            font-size: 1.5rem;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
        }

        .card h2 i {
            margin-right: 10px;
        }

        .media-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .video-container, .canvas-container {
            position: relative;
            width: 100%;
            height: 240px;
            border-radius: 10px;
            overflow: hidden;
            background: #000;
        }

        video, canvas {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .obstruction-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 1.2rem;
            text-align: center;
            z-index: 10;
            backdrop-filter: blur(5px);
        }

        .obstruction-overlay.hidden {
            display: none;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }

        button {
            background: linear-gradient(135deg, #4776E6, #8E54E9);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 50px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .toggle-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-left: auto;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background: linear-gradient(135deg, #4776E6, #8E54E9);
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        .results {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }

        .result-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .result-card h3 {
            font-size: 1.2rem;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
        }

        .result-card h3 i {
            margin-right: 10px;
        }

        .prediction {
            font-size: 1.1rem; /* Adjusted for longer text from Gemini */
            font-weight: bold;
            text-align: center;
            margin: 15px 0;
            padding: 10px;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.2);
            min-height: 80px; /* Ensure space for text */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .rain-likely {
            background: linear-gradient(135deg, #ff416c, #ff4b2b);
        }

        .rain-possible {
            background: linear-gradient(135deg, #f7971e, #ffd200);
        }

        .no-rain {
            background: linear-gradient(135deg, #00b09b, #96c93d);
        }

        .metric {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .metric:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .metric-value {
            font-weight: bold;
        }

        .progress-bar {
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            margin-top: 5px;
            overflow: hidden;
        }

        .progress {
            height: 100%;
            background: linear-gradient(135deg, #4776E6, #8E54E9);
            border-radius: 4px;
            transition: width 0.5s ease;
        }

        .confidence-high {
            background: linear-gradient(135deg, #00b09b, #96c93d);
        }

        .confidence-medium {
            background: linear-gradient(135deg, #f7971e, #ffd200);
        }

        .confidence-low {
            background: linear-gradient(135deg, #ff416c, #ff4b2b);
        }

        footer {
            text-align: center;
            margin-top: 40px;
            padding: 20px;
            font-size: 0.9rem;
            opacity: 0.7;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .status {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
            font-size: 0.9rem;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ff4b2b;
        }

        .status-dot.active {
            background: #00b09b;
        }
        
        .image-label {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 5;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>SkyPredict</h1>
            <p class="tagline">Real-time rain prediction using your camera and environmental data</p>
        </header>

        <div class="dashboard">
            <div class="card">
                <h2><i>📹</i> Camera Feed</h2>
                <div class="media-container">
                    <div class="video-container">
                        <video id="video" autoplay playsinline></video>
                        <canvas id="frozenCanvas" style="display: none;"></canvas>
                        <div class="image-label" id="topLabel" style="display: none;">Frozen Image</div>
                        <div class="obstruction-overlay hidden" id="obstructionOverlay">
                            <i style="font-size: 3rem; margin-bottom: 15px;">⚠️</i>
                            <p id="obstructionMessage">Obstruction detected</p>
                        </div>
                    </div>
                    <div class="canvas-container">
                        <canvas id="canvas"></canvas>
                        <div class="image-label" id="bottomLabel" style="display: none;">Negative Image</div>
                    </div>
                </div>
                <div class="controls">
                    <button id="startBtn">
                        <i>▶️</i> Start Camera
                    </button>
                    <button id="captureBtn" disabled>
                        <i>🌧️</i> Analyze Sky
                    </button>
                    <div class="toggle-container">
                        <label for="maskToggle">Sky Masking</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="maskToggle" checked>
                            <span class="slider"></span>
                        </label>
                    </div>
                </div>
                <div class="status">
                    <div class="status-dot" id="cameraStatus"></div>
                    <span id="cameraStatusText">Camera not active</span>
                </div>
            </div>

            <div class="card">
                <h2><i>📊</i> Prediction Results</h2>
                <div id="output">
                    <div class="prediction" id="prediction">—</div>
                    
                    <div class="metric">
                        <span>Rain Probability</span>
                        <span class="metric-value" id="rainProbability">—</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress" id="rainProbabilityBar" style="width: 0%"></div>
                    </div>
                    
                    <div class="metric">
                        <span>Estimated Rain Rate</span>
                        <span class="metric-value" id="rainRate">— mm/hr</span>
                    </div>
                    
                    <div class="metric">
                        <span>Cloudiness</span>
                        <span class="metric-value" id="cloudiness">—</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress" id="cloudinessBar" style="width: 0%"></div>
                    </div>
                    
                    <div class="metric">
                        <span>Sky Clarity</span>
                        <span class="metric-value" id="skyClarity">—</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress" id="skyClarityBar" style="width: 0%"></div>
                    </div>
                </div>
                
                <div class="status">
                    <div class="status-dot" id="analysisStatus"></div>
                    <span id="analysisStatusText">Ready for analysis</span>
                </div>
            </div>
        </div>

        <div class="results">
            <div class="result-card">
                <h3><i>🌍</i> Environmental Data</h3>
                <div class="metric">
                    <span>Humidity</span>
                    <span class="metric-value" id="humidity">—%</span>
                </div>
                <div class="progress-bar">
                    <div class="progress" id="humidityBar" style="width: 0%"></div>
                </div>
                
                <div class="metric">
                    <span>Cloud Cover</span>
                    <span class="metric-value" id="cloudCover">—%</span>
                </div>
                <div class="progress-bar">
                    <div class="progress" id="cloudCoverBar" style="width: 0%"></div>
                </div>
                
                <div class="metric">
                    <span>Temperature</span>
                    <span class="metric-value" id="temperature">—°C</span>
                </div>
            </div>
            
            <div class="result-card">
                <h3><i>📈</i> Analysis Metrics</h3>
                <div class="metric">
                    <span>Edge Density</span>
                    <span class="metric-value" id="edgeDensity">—</span>
                </div>
                <div class="progress-bar">
                    <div class="progress" id="edgeDensityBar" style="width: 0%"></div>
                </div>
                
                <div class="metric">
                    <span>Blue Channel</span>
                    <span class="metric-value" id="blueChannel">—</span>
                </div>
                <div class="progress-bar">
                    <div class="progress" id="blueChannelBar" style="width: 0%"></div>
                </div>
                
                <div class="metric">
                    <span>Processing Time</span>
                    <span class="metric-value" id="processingTime">— ms</span>
                </div>
            </div>
            
            <div class="result-card">
                <h3><i>🔮</i> Forecast</h3>
                <div class="metric">
                    <span>Next 1 hour</span>
                    <span class="metric-value" id="next1Hour">—</span>
                </div>
                <div class="metric">
                    <span>Next 3 hours</span>
                    <span class="metric-value" id="next3Hours">—</span>
                </div>
                <div class="metric">
                    <span>Next 6 hours</span>
                    <span class="metric-value" id="next6Hours">—</span>
                </div>
                <div class="metric">
                    <span>Confidence</span>
                    <span class="metric-value" id="confidence">—</span>
                </div>
                <div class="progress-bar">
                    <div class="progress" id="confidenceBar" style="width: 0%"></div>
                </div>
            </div>
        </div>

        <footer>
            <p>SkyPredict Demo | Real-time rain prediction using computer vision and environmental data fusion</p>
        </footer>
    </div>

    <script>
    // --- START OF NEW SCRIPT ---

    // DOM Elements
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const frozenCanvas = document.getElementById('frozenCanvas');
    const startBtn = document.getElementById('startBtn');
    const captureBtn = document.getElementById('captureBtn');
    const maskToggle = document.getElementById('maskToggle');
    const cameraStatus = document.getElementById('cameraStatus');
    const cameraStatusText = document.getElementById('cameraStatusText');
    const analysisStatus = document.getElementById('analysisStatus');
    const analysisStatusText = document.getElementById('analysisStatusText');
    const topLabel = document.getElementById('topLabel');
    const bottomLabel = document.getElementById('bottomLabel');
    
    // Result elements
    const predictionEl = document.getElementById('prediction');
    const rainProbabilityEl = document.getElementById('rainProbability');
    const rainProbabilityBar = document.getElementById('rainProbabilityBar');
    const humidityEl = document.getElementById('humidity');
    const humidityBar = document.getElementById('humidityBar');
    const cloudCoverEl = document.getElementById('cloudCover');
    const cloudCoverBar = document.getElementById('cloudCoverBar');
    const temperatureEl = document.getElementById('temperature');
    const processingTimeEl = document.getElementById('processingTime');


    // Canvas context
    const ctx = canvas.getContext('2d');
    const frozenCtx = frozenCanvas.getContext('2d');
    canvas.width = 640;
    canvas.height = 480;
    frozenCanvas.width = 640;
    frozenCanvas.height = 480;

    // State variables
    let isCameraActive = false;
    let stream = null;
    let isAnalyzing = false;
    let isFrozen = false;
    
    // In index.html, replace the old Gemini functions with these:

/**
 * Asks our secure Vercel function if the provided image is a valid sky photo.
 * @param {string} imageDataBase64 The base64-encoded image data.
 * @returns {Promise<boolean>} True if the image is approved, false otherwise.
 */
async function isSkyImageApproved(imageDataBase64) {
    const url = '/api/gemini'; // This is our new secure endpoint

    const requestBody = {
        "contents": [{
            "parts": [
                { "text": "Analyze this image. Is the primary subject the sky, clouds, sunrise, or sunset? There should be no significant obstructions like buildings, people, or indoor objects. Answer with only 'YES' or 'NO'." },
                {
                    "inline_data": {
                        "mime_type": "image/jpeg",
                        "data": imageDataBase64
                    }
                }
            ]
        }],
        "generationConfig": { "maxOutputTokens": 5 }
    };

    try {
        const response = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
            console.error("API Error:", response.status, await response.text());
            analysisStatusText.textContent = 'Approval API Error.';
            return false;
        }

        const data = await response.json();
        const textResponse = data.candidates[0].content.parts[0].text;
        console.log("Gemini Approval Response:", textResponse);
        return textResponse.trim().toUpperCase() === 'YES';

    } catch (error) {
        console.error("Error calling our API:", error);
        analysisStatusText.textContent = 'Network error during approval.';
        return false;
    }
}

/**
 * Asks our secure Vercel function for a detailed weather analysis.
 * @param {string} imageDataBase64 The base64-encoded image data.
 * @param {object} weatherData An object with humidity, cloudCover, and temperature.
 * @returns {Promise<string>} The textual weather forecast from Gemini.
 */
async function getFusedWeatherAnalysis(imageDataBase64, weatherData) {
    const url = '/api/gemini'; // Use the same secure endpoint

    const prompt = `You are a weather prediction assistant. Based on this real-time image of the sky and the following environmental data for Kozhikode, Kerala, India:
    - Humidity: ${weatherData.humidity}%
    - Cloud Cover: ${weatherData.cloudCover}%
    - Temperature: ${weatherData.temperature}°C
    Provide a short, user-friendly weather prediction (2-3 sentences). Focus on the immediate likelihood of rain.`;

    const requestBody = {
        "contents": [{
            "parts": [
                { "text": prompt },
                {
                    "inline_data": {
                        "mime_type": "image/jpeg",
                        "data": imageDataBase64
                    }
                }
            ]
        }]
    };

    try {
        const response = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
            return "Could not get a detailed analysis.";
        }

        const data = await response.json();
        return data.candidates[0].content.parts[0].text;

    } catch (error) {
        console.error("Error calling our API for analysis:", error);
        return "Analysis failed due to a network error.";
    }
}


    // --- MODIFIED CORE FUNCTIONS ---

    // Start webcam
    async function startWebcam() {
        try {
            stream = await navigator.mediaDevices.getUserMedia({
                video: { 
                    facingMode: "environment",
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                },
                audio: false
            });
            
            video.srcObject = stream;
            await video.play();
            
            isCameraActive = true;
            isAnalyzing = false;
            isFrozen = false;
            cameraStatus.classList.add('active');
            cameraStatusText.textContent = 'Camera active';
            startBtn.innerHTML = '<i>⏹️</i> Stop Camera';
            captureBtn.disabled = false;
            
            // Show video and hide frozen canvas
            video.style.display = 'block';
            frozenCanvas.style.display = 'none';
            topLabel.style.display = 'none';
            bottomLabel.style.display = 'none';
            document.getElementById('obstructionOverlay').classList.add('hidden');
            
            // Start drawing video to canvas (for visual feedback)
            drawVideoToCanvas();
            
        } catch (err) {
            console.error("Error accessing camera:", err);
            alert("Could not access camera: " + err.message);
        }
    }

    // Stop webcam
    function stopWebcam() {
        if (stream) {
            stream.getTracks().forEach(track => track.stop());
            stream = null;
        }
        
        isCameraActive = false;
        cameraStatus.classList.remove('active');
        cameraStatusText.textContent = 'Camera not active';
        startBtn.innerHTML = '<i>▶️</i> Start Camera';
        captureBtn.disabled = true;
        
        if (!isFrozen) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            frozenCtx.clearRect(0, 0, frozenCanvas.width, frozenCanvas.height);
            video.style.display = 'block';
            frozenCanvas.style.display = 'none';
            topLabel.style.display = 'none';
            bottomLabel.style.display = 'none';
        }
    }

    // Draw video to canvas (this function is simpler now)
    function drawVideoToCanvas() {
        if (!isCameraActive || isFrozen) return;
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        if (maskToggle.checked) {
            applySkyMasking();
        }
        requestAnimationFrame(drawVideoToCanvas);
    }
    
    // Create negative image from source canvas
    function createNegativeImage(sourceCanvas, targetCanvas) {
        const targetCtx = targetCanvas.getContext('2d');
        targetCtx.drawImage(sourceCanvas, 0, 0, targetCanvas.width, targetCanvas.height);
        const imageData = targetCtx.getImageData(0, 0, targetCanvas.width, targetCanvas.height);
        const data = imageData.data;
        for (let i = 0; i < data.length; i += 4) {
            data[i] = 255 - data[i];     // Red
            data[i + 1] = 255 - data[i + 1]; // Green
            data[i + 2] = 255 - data[i + 2]; // Blue
        }
        targetCtx.putImageData(imageData, 0, 0);
    }

    // Apply simple sky masking (upper portion of the image)
    function applySkyMasking() {
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height * 0.6);
        gradient.addColorStop(0, 'rgba(0, 0, 0, 0.7)');
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height * 0.6);
        ctx.fillStyle = 'white';
        ctx.font = '16px Arial';
        ctx.fillText('Sky Analysis Region', 10, 30);
    }


    // --- COMPLETELY REWRITTEN analyzeFrame FUNCTION ---
    async function analyzeFrame() {
        if (!isCameraActive || isAnalyzing) return;
        
        isAnalyzing = true;
        isFrozen = true;
        const startTime = performance.now();
        
        analysisStatus.classList.remove('active');
        analysisStatusText.innerHTML = '<span class="loading"></span> Freezing frame...';
        
        // 1. Freeze the current frame
        frozenCtx.drawImage(video, 0, 0, frozenCanvas.width, frozenCanvas.height);
        video.style.display = 'none';
        frozenCanvas.style.display = 'block';
        topLabel.style.display = 'block';
        createNegativeImage(frozenCanvas, canvas);
        bottomLabel.style.display = 'block';

        // 2. Get image data for the API
        // We strip the data URL prefix to get the pure base64 string
        const imageDataUrl = frozenCanvas.toDataURL('image/jpeg', 0.8);
        const imageDataBase64 = imageDataUrl.split(',')[1];

        // 3. Ask Gemini for approval
        analysisStatusText.innerHTML = '<span class="loading"></span> Verifying sky image...';
        const isApproved = await isSkyImageApproved(imageDataBase64);

        if (!isApproved) {
            analysisStatusText.textContent = 'Image rejected. Please point at the sky.';
            predictionEl.textContent = "Analysis Failed: Obstruction Detected";
            predictionEl.className = "prediction rain-likely"; // Use red for error
            isAnalyzing = false;
            // Optionally, unfreeze here or wait for user to restart
            // stopWebcam(); // Or just leave it frozen
            return;
        }

        // 4. If approved, get the fused analysis
        analysisStatusText.innerHTML = '<span class="loading"></span> Image approved. Analyzing weather...';
        
        // Create some mock environmental data (in a real app, you'd fetch this from a weather API)
        const mockWeatherData = {
            humidity: (60 + Math.random() * 30).toFixed(0),
            cloudCover: (40 + Math.random() * 50).toFixed(0),
            temperature: (25 + Math.random() * 5).toFixed(0)
        };
        
        // Update the UI with the data we have
        humidityEl.textContent = `${mockWeatherData.humidity}%`;
        humidityBar.style.width = `${mockWeatherData.humidity}%`;
        cloudCoverEl.textContent = `${mockWeatherData.cloudCover}%`;
        cloudCoverBar.style.width = `${mockWeatherData.cloudCover}%`;
        temperatureEl.textContent = `${mockWeatherData.temperature}°C`;

        const analysisResult = await getFusedWeatherAnalysis(imageDataBase64, mockWeatherData);

        // 5. Display the final result
        predictionEl.textContent = analysisResult;
        predictionEl.className = "prediction"; // Reset class to default
        rainProbabilityEl.textContent = "N/A"; // Gemini gives text, not a number
        rainProbabilityBar.style.width = `0%`; // Reset bar

        processingTimeEl.textContent = `${(performance.now() - startTime).toFixed(0)} ms`;
        analysisStatus.classList.add('active');
        analysisStatusText.textContent = 'Analysis complete.';
        isAnalyzing = false;
    }


    // Event listeners
    startBtn.addEventListener('click', () => {
        if (isCameraActive) {
            stopWebcam();
        } else {
            startWebcam();
        }
    });

    captureBtn.addEventListener('click', () => {
        analyzeFrame();
    });

    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
        cameraStatusText.textContent = 'Camera not active';
        analysisStatusText.textContent = 'Ready for analysis';
    });

    // --- END OF NEW SCRIPT ---
    </script>
</body>
</html>
